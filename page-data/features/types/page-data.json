{"componentChunkName":"component---src-templates-docs-js","path":"/features/types","webpackCompilationHash":"e536b55f7567f3131f54","result":{"data":{"site":{"siteMetadata":{"title":"EOPI-JS","docsLocation":"https://github.com/brianc/node-postgres-docs/tree/master/content"}},"mdx":{"fields":{"id":"3f5b40dd-eb6a-5160-baf5-6621645350f3","title":"Data Types","slug":"/features/types"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Data Types\",\n  \"slug\": \"/features/types\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"PostgreSQL has a rich system of supported \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.postgresql.org/docs/9.5/static/datatype.html\"\n  }), \"data types\"), \". node-postgres does its best to support the most common data types out of the box and supplies an extensible type parser to allow for custom type serialization and parsing.\"), mdx(\"h2\", {\n    \"id\": \"strings-by-default\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"strings by default\"), mdx(\"p\", null, \"node-postgres will convert a database type to a JavaScript string if it doesn't have a registered type parser for the database type. Furthermore, you can send any type to the PostgreSQL server as a string and node-postgres will pass it through without modifying it in any way. To circumvent the type parsing completely do something like the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const queryText = 'SELECT int_col::text, date_col::text, json_col::text FROM my_table'\\nconst result = await client.query(queryText)\\n\\nconsole.log(result.rows[0]) // will contain the unparsed string value of each column\\n\")), mdx(\"h2\", {\n    \"id\": \"type-parsing-examples\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"type parsing examples\"), mdx(\"h3\", {\n    \"id\": \"uuid--json--jsonb\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"uuid + json / jsonb\"), mdx(\"p\", null, \"There is no data type in JavaScript for a uuid/guid so node-postgres converts a uuid to a string. JavaScript has great support for JSON and node-postgres converts json/jsonb objects directly into their JavaScript object via \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-types/blob/master/lib/textParsers.js#L193\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"JSON.parse\")), \". Likewise sending an object to the PostgreSQL server via a query from node-postgres, node-posgres will call \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-postgres/blob/e5f0e5d36a91a72dda93c74388ac890fa42b3be0/lib/utils.js#L47\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"JSON.stringify\")), \" on your outbound value, automatically converting it to json for the server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const createTableText = `\\nCREATE EXTENSION IF NOT EXISTS \\\"pgcrypto\\\";\\n\\nCREATE TEMP TABLE IF NOT EXISTS users (\\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\\n  data JSONB\\n);\\n`\\n// create our temp table\\nawait client.query(createTableText)\\n\\nconst newUser = { email: 'brian.m.carlson@gmail.com' }\\n// create a new user\\nawait client.query('INSERT INTO users(data) VALUES($1)', [newUser])\\n\\nconst { rows } = await client.query('SELECT * FROM users')\\n\\nconsole.log(rows)\\n/*\\noutput:\\n[{\\n  id: 'd70195fd-608e-42dc-b0f5-eee975a621e9',\\n  data: { email: 'brian.m.carlson@gmail.com' }\\n}]\\n*/\\n\")), mdx(\"h3\", {\n    \"id\": \"date--timestamp--timestamptz\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"date / timestamp / timestamptz\"), mdx(\"p\", null, \"node-postgres will convert instances of JavaScript date objects into the expected input value for your PostgreSQL server. Likewise, when reading a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"date\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timestamp\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timestamptz\"), \" column value back into JavaScript, node-postgres will parse the value into an instance of a JavaScript \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Date\"), \" object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const createTableText = `\\nCREATE TEMP TABLE dates(\\n  date_col DATE,\\n  timestamp_col TIMESTAMP,\\n  timestamptz_col TIMESTAMPTZ\\n);\\n`\\n// create our temp table\\nawait client.query(createTableText)\\n\\n// insert the current time into it\\nconst now = new Date()\\nconst insertText = 'INSERT INTO dates(date_col, timestamp_col, timestamptz_col) VALUES ($1, $2, $3)'\\nawait client.query(insertText, [now, now, now])\\n\\n// read the row back out\\nconst result = await client.query('SELECT * FROM dates')\\n\\nconsole.log(result.rows)\\n// {\\n// date_col: 2017-05-29T05:00:00.000Z,\\n// timestamp_col: 2017-05-29T23:18:13.263Z,\\n// timestamptz_col: 2017-05-29T23:18:13.263Z\\n// }\\n\")), mdx(\"p\", null, \"psql output:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-psql\"\n  }), \"bmc=# select * from dates;\\n  date_col  |      timestamp_col      |      timestamptz_col\\n------------+-------------------------+----------------------------\\n 2017-05-29 | 2017-05-29 18:18:13.263 | 2017-05-29 18:18:13.263-05\\n(1 row)\\n\")), mdx(\"p\", null, \"node-postgres converts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DATE\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TIMESTAMP\"), \" columns into the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"local\"), \" time of the node process set at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process.env.TZ\"), \".\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I generally use \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"TIMESTAMPTZ\"), \" when storing dates; otherwise, inserting a time from a process in one timezone and reading it out in a process in another timezone can cause unexpected differences in the time.\")), mdx(\"div\", {\n    className: \"message is-warning\"\n  }, mdx(\"div\", {\n    className: \"message-body\"\n  }, \"Although PostgreSQL supports microseconds in dates, JavaScript only supports dates to the millisecond precision.  Keep this in mind when you send dates to and from PostgreSQL from node: your microseconds will be truncated when converting to a JavaScript date object even if they exist in the database.  If you need to preserve them, I recommend using a custom type parser.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#strings-by-default","title":"strings by default"},{"url":"#type-parsing-examples","title":"type parsing examples","items":[{"url":"#uuid--json--jsonb","title":"uuid + json / jsonb"},{"url":"#date--timestamp--timestamptz","title":"date / timestamp / timestamptz"}]}]},"parent":{"__typename":"File","relativePath":"features/5-types.mdx"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/features","title":"Features","filename":{"name":"features"}}}},{"node":{"fields":{"slug":"/guides","title":"Guides","filename":{"name":"guides"}}}},{"node":{"fields":{"slug":"/api","title":"API","filename":{"name":"api"}}}},{"node":{"fields":{"slug":"/api/result","title":"pg.Result","filename":{"name":"3-result"}}}},{"node":{"fields":{"slug":"/api/types","title":"Types","filename":{"name":"4-types"}}}},{"node":{"fields":{"slug":"/features/queries","title":"Queries","filename":{"name":"2-queries"}}}},{"node":{"fields":{"slug":"/features/pooling","title":"Pooling","filename":{"name":"3-pooling"}}}},{"node":{"fields":{"slug":"/features/transactions","title":"Transactions","filename":{"name":"4-transactions"}}}},{"node":{"fields":{"slug":"/features/ssl","title":"SSL","filename":{"name":"6-ssl"}}}},{"node":{"fields":{"slug":"/features/native","title":"Native Bindings","filename":{"name":"7-native"}}}},{"node":{"fields":{"slug":"/features/types","title":"Data Types","filename":{"name":"5-types"}}}},{"node":{"fields":{"slug":"/features/connecting","title":"Connecting","filename":{"name":"1-connecting"}}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Suggested Project Structure","filename":{"name":"1-project-structure"}}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Express with async/await","filename":{"name":"2-async-express"}}}},{"node":{"fields":{"slug":"/api/cursor","title":"pg.Cursor","filename":{"name":"5-cursor"}}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading","filename":{"name":"3-upgrading"}}}},{"node":{"fields":{"slug":"/announcements","title":"Announcements","filename":{"name":"announcements"}}}},{"node":{"fields":{"slug":"/api/client","title":"pg.Client","filename":{"name":"2-client"}}}},{"node":{"fields":{"slug":"/api/pool","title":"pg.Pool","filename":{"name":"1-pool"}}}},{"node":{"fields":{"slug":"/","title":"Welcome","filename":{"name":"welcome"}}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"3f5b40dd-eb6a-5160-baf5-6621645350f3"}}}