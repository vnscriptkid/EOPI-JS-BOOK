{"componentChunkName":"component---src-templates-docs-js","path":"/api/result","webpackCompilationHash":"e536b55f7567f3131f54","result":{"data":{"site":{"siteMetadata":{"title":"EOPI-JS","docsLocation":"https://github.com/brianc/node-postgres-docs/tree/master/content"}},"mdx":{"fields":{"id":"5d6a4137-96b9-536e-b8a6-393e3929ff48","title":"pg.Result","slug":"/api/result"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"pg.Result\",\n  \"slug\": \"/api/result\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg.Result\"), \" shape is returned for every successful query.\"), mdx(\"div\", {\n    className: \"alert alert-info\"\n  }, \"note: you cannot instantiate this directly\"), mdx(\"h2\", {\n    \"id\": \"properties\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"properties\"), mdx(\"h3\", {\n    \"id\": \"resultrows-arrayany\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"result.rows: Array<any>\")), mdx(\"p\", null, \"Every result will have a rows array. If no rows are returned the array will be empty. Otherwise the array will contain one item for each row returned from the query. By default node-postgres creates a map from the name to value of each column, giving you a json-like object back for each row.\"), mdx(\"h3\", {\n    \"id\": \"resultfields-arrayfieldinfo\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"result.fields: Array<FieldInfo>\")), mdx(\"p\", null, \"Every result will have a fields array. This array contains the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dataTypeID\"), \" of each field in the result. These fields are ordered in the same order as the columns if you are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"arrayMode\"), \" for the query:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nconst client = await pool.connect()\\nconst result = await client.query({\\n  rowMode: 'array',\\n  text: 'SELECT 1 as one, 2 as two;',\\n})\\nconsole.log(result.fields[0].name) // one\\nconsole.log(result.fields[1].name) // two\\nconsole.log(result.rows) // [ [ 1, 2 ] ]\\nawait client.end()\\n\")), mdx(\"h3\", {\n    \"id\": \"resultcommand-string\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"result.command: string\")), mdx(\"p\", null, \"The command type last executed: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INSERT\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UPDATE\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CREATE\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SELECT\"), \" etc.\"), mdx(\"h3\", {\n    \"id\": \"resultrowcount-int\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"result.rowCount: int\")), mdx(\"p\", null, \"The number of rows processed by the last command. \"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: this does not reflect the number of rows \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"returned\"), \" from a query.  e.g. an update statement could update many rows (so high \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"result.rowCount\"), \" value) but \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"result.rows.length\"), \" would be zero.  To check for an empty query reponse on a \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"SELECT\"), \" query use \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"result.rows.length === 0\")), \".\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-postgres/issues/2182#issuecomment-620553915\"\n  }), \"@sehrope\"), \" has a good explanation:\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rowCount\"), \" is populated from the command tag supplied by the PostgreSQL server. It's generally of the form: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"COMMAND [OID] [ROWS]\")), mdx(\"p\", null, \"For DML commands (INSERT, UPDATE, etc), it reflects how many rows the server modified to process the command. For SELECT or COPY commands it reflects how many rows were retrieved or copied. More info on the specifics here: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.postgresql.org/docs/current/protocol-message-formats.html\"\n  }), \"https://www.postgresql.org/docs/current/protocol-message-formats.html\"), \" (search for CommandComplete for the message type)\"), mdx(\"p\", null, \"The note in the docs about the difference is because that value is controlled by the server. It's possible for a non-standard server (ex: PostgreSQL fork) or a server version in the future to provide different information in some situations so it'd be best not to rely on it to assume that the rows array length matches the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rowCount\"), \". It's fine to use it for DML counts though.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#properties","title":"properties","items":[{"url":"#resultrows-arrayany","title":"result.rows: Array<any>"},{"url":"#resultfields-arrayfieldinfo","title":"result.fields: Array<FieldInfo>"},{"url":"#resultcommand-string","title":"result.command: string"},{"url":"#resultrowcount-int","title":"result.rowCount: int"}]}]},"parent":{"__typename":"File","relativePath":"api/3-result.mdx"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/features","title":"Features","filename":{"name":"features"}}}},{"node":{"fields":{"slug":"/guides","title":"Guides","filename":{"name":"guides"}}}},{"node":{"fields":{"slug":"/api","title":"API","filename":{"name":"api"}}}},{"node":{"fields":{"slug":"/api/result","title":"pg.Result","filename":{"name":"3-result"}}}},{"node":{"fields":{"slug":"/api/types","title":"Types","filename":{"name":"4-types"}}}},{"node":{"fields":{"slug":"/features/queries","title":"Queries","filename":{"name":"2-queries"}}}},{"node":{"fields":{"slug":"/features/pooling","title":"Pooling","filename":{"name":"3-pooling"}}}},{"node":{"fields":{"slug":"/features/transactions","title":"Transactions","filename":{"name":"4-transactions"}}}},{"node":{"fields":{"slug":"/features/ssl","title":"SSL","filename":{"name":"6-ssl"}}}},{"node":{"fields":{"slug":"/features/native","title":"Native Bindings","filename":{"name":"7-native"}}}},{"node":{"fields":{"slug":"/features/types","title":"Data Types","filename":{"name":"5-types"}}}},{"node":{"fields":{"slug":"/features/connecting","title":"Connecting","filename":{"name":"1-connecting"}}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Suggested Project Structure","filename":{"name":"1-project-structure"}}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Express with async/await","filename":{"name":"2-async-express"}}}},{"node":{"fields":{"slug":"/api/cursor","title":"pg.Cursor","filename":{"name":"5-cursor"}}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading","filename":{"name":"3-upgrading"}}}},{"node":{"fields":{"slug":"/announcements","title":"Announcements","filename":{"name":"announcements"}}}},{"node":{"fields":{"slug":"/api/client","title":"pg.Client","filename":{"name":"2-client"}}}},{"node":{"fields":{"slug":"/api/pool","title":"pg.Pool","filename":{"name":"1-pool"}}}},{"node":{"fields":{"slug":"/","title":"Welcome","filename":{"name":"welcome"}}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"5d6a4137-96b9-536e-b8a6-393e3929ff48"}}}