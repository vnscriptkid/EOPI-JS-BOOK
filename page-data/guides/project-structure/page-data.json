{"componentChunkName":"component---src-templates-docs-js","path":"/guides/project-structure","webpackCompilationHash":"e536b55f7567f3131f54","result":{"data":{"site":{"siteMetadata":{"title":"EOPI-JS","docsLocation":"https://github.com/brianc/node-postgres-docs/tree/master/content"}},"mdx":{"fields":{"id":"96180818-30b8-53e6-a213-629ddc66f144","title":"Suggested Project Structure","slug":"/guides/project-structure"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Suggested Project Structure\",\n  \"slug\": \"/guides/project-structure\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Whenever I am writing a project & using node-postgres I like to create a file within it and make all interactions with the database go through this file. This serves a few purposes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows my project to adjust to any changes to the node-postgres API without having to trace down all the places I directly use node-postgres in my application.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows me to have a single place to put logging and diagnostics around my database.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows me to make custom extensions to my database access code & share it throughout the project.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows a single place to bootstrap & configure the database.\")), mdx(\"h2\", {\n    \"id\": \"example\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"example\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I am using callbacks in this example to introduce as few concepts as possible at a time, but the same is doable with promises or async/await\")), mdx(\"p\", null, \"The location doesn't really matter - I've found it usually ends up being somewhat app specific and in line with whatever folder structure conventions you're using. For this example I'll use an express app structured like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"- app.js\\n- index.js\\n- routes/\\n  - index.js\\n  - photos.js\\n  - user.js\\n- db/\\n  - index.js <--- this is where I put data access code\\n\")), mdx(\"p\", null, \"Typically I'll start out my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/index.js\"), \" file like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) => {\\n    return pool.query(text, params, callback)\\n  },\\n}\\n\")), mdx(\"p\", null, \"That's it. But now everywhere else in my application instead of requiring \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg\"), \" directly, I'll require this file. Here's an example of a route within \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/user.js\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// notice here I'm requiring my database adapter file\\n// and not requiring node-postgres directly\\nconst db = require('../db')\\n\\napp.get('/:id', (req, res, next) => {\\n  db.query('SELECT * FROM users WHERE id = $1', [req.params.id], (err, result) => {\\n    if (err) {\\n      return next(err)\\n    }\\n    res.send(result.rows[0])\\n  })\\n})\\n\\n// ... many other routes in this file\\n\")), mdx(\"p\", null, \"Imagine we have lots of routes scattered throughout many files under our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/\"), \" directory. We now want to go back and log every single query that's executed, how long it took, and the number of rows it returned. If we had required node-postgres directly in every route file we'd have to go edit every single route - that would take forever & be really error prone! But thankfully we put our data access into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/index.js\"), \". Let's go add some logging:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) => {\\n    const start = Date.now()\\n    return pool.query(text, params, (err, res) => {\\n      const duration = Date.now() - start\\n      console.log('executed query', { text, duration, rows: res.rowCount })\\n      callback(err, res)\\n    })\\n  },\\n}\\n\")), mdx(\"p\", null, \"That was pretty quick! And now all of our queries everywhere in our application are being logged.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I didn't log the query parameters.  Depending on your application you might be storing encrypted passwords or other sensitive information in your database.  If you log your query parameters you might accidentally log sensitive information.  Every app is different though so do what suits you best!\")), mdx(\"p\", null, \"Now what if we need to check out a client from the pool to run several queries in a row in a transaction? We can add another method to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/index.js\"), \" file when we need to do this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) => {\\n    const start = Date.now()\\n    return pool.query(text, params, (err, res) => {\\n      const duration = Date.now() - start\\n      console.log('executed query', { text, duration, rows: res.rowCount })\\n      callback(err, res)\\n    })\\n  },\\n  getClient: (callback) => {\\n    pool.connect((err, client, done) => {\\n      callback(err, client, done)\\n    })\\n  }\\n}\\n\")), mdx(\"p\", null, \"Okay. Great - the simplest thing that could possibly work. It seems like one of our routes that checks out a client to run a transaction is forgetting to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done\"), \" in some situation! Oh no! We are leaking a client & have hundreds of these routes to go audit. Good thing we have all our client access going through this single file. Lets add some deeper diagnostic information here to help us track down where the client leak is happening.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) => {\\n    const start = Date.now()\\n    return pool.query(text, params, (err, res) => {\\n      const duration = Date.now() - start\\n      console.log('executed query', { text, duration, rows: res.rowCount })\\n      callback(err, res)\\n    })\\n  },\\n  getClient: (callback) => {\\n    pool.connect((err, client, done) => {\\n      const query = client.query\\n\\n      // monkey patch the query method to keep track of the last query executed\\n      client.query = (...args) => {\\n        client.lastQuery = args\\n        return query.apply(client, args)\\n      }\\n\\n      // set a timeout of 5 seconds, after which we will log this client's last query\\n      const timeout = setTimeout(() => {\\n        console.error('A client has been checked out for more than 5 seconds!')\\n        console.error(`The last executed query on this client was: ${client.lastQuery}`)\\n      }, 5000)\\n\\n      const release = (err) => {\\n        // call the actual 'done' method, returning this client to the pool\\n        done(err)\\n\\n        // clear our timeout\\n        clearTimeout(timeout)\\n\\n        // set the query method back to its old un-monkey-patched version\\n        client.query = query\\n      }\\n\\n      callback(err, client, release)\\n    })\\n  }\\n}\\n\")), mdx(\"p\", null, \"Using async/await:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"module.exports = {\\n  async query(text, params) {\\n    const start = Date.now()\\n    const res = await pool.query(text, params)\\n    const duration = Date.now() - start\\n    console.log('executed query', { text, duration, rows: res.rowCount })\\n    return res\\n  },\\n\\n  async getClient() {\\n    const client = await pool.connect()\\n    const query = client.query\\n    const release = client.release\\n    // set a timeout of 5 seconds, after which we will log this client's last query\\n    const timeout = setTimeout(() => {\\n      console.error('A client has been checked out for more than 5 seconds!')\\n      console.error(`The last executed query on this client was: ${client.lastQuery}`)\\n    }, 5000)\\n    // monkey patch the query method to keep track of the last query executed\\n    client.query = (...args) => {\\n      client.lastQuery = args\\n      return query.apply(client, args)\\n    }\\n    client.release = () => {\\n      // clear our timeout\\n      clearTimeout(timeout)\\n      // set the methods back to their old un-monkey-patched version\\n      client.query = query\\n      client.release = release\\n      return release.apply(client)\\n    }\\n    return client\\n  }\\n}\\n\")), mdx(\"p\", null, \"That should hopefully give us enough diagnostic information to track down any leaks.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#example","title":"example"}]},"parent":{"__typename":"File","relativePath":"guides/1-project-structure.md"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/features","title":"Features","filename":{"name":"features"}}}},{"node":{"fields":{"slug":"/guides","title":"Guides","filename":{"name":"guides"}}}},{"node":{"fields":{"slug":"/api","title":"API","filename":{"name":"api"}}}},{"node":{"fields":{"slug":"/api/result","title":"pg.Result","filename":{"name":"3-result"}}}},{"node":{"fields":{"slug":"/api/types","title":"Types","filename":{"name":"4-types"}}}},{"node":{"fields":{"slug":"/features/queries","title":"Queries","filename":{"name":"2-queries"}}}},{"node":{"fields":{"slug":"/features/pooling","title":"Pooling","filename":{"name":"3-pooling"}}}},{"node":{"fields":{"slug":"/features/transactions","title":"Transactions","filename":{"name":"4-transactions"}}}},{"node":{"fields":{"slug":"/features/ssl","title":"SSL","filename":{"name":"6-ssl"}}}},{"node":{"fields":{"slug":"/features/native","title":"Native Bindings","filename":{"name":"7-native"}}}},{"node":{"fields":{"slug":"/features/types","title":"Data Types","filename":{"name":"5-types"}}}},{"node":{"fields":{"slug":"/features/connecting","title":"Connecting","filename":{"name":"1-connecting"}}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Suggested Project Structure","filename":{"name":"1-project-structure"}}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Express with async/await","filename":{"name":"2-async-express"}}}},{"node":{"fields":{"slug":"/api/cursor","title":"pg.Cursor","filename":{"name":"5-cursor"}}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading","filename":{"name":"3-upgrading"}}}},{"node":{"fields":{"slug":"/announcements","title":"Announcements","filename":{"name":"announcements"}}}},{"node":{"fields":{"slug":"/api/client","title":"pg.Client","filename":{"name":"2-client"}}}},{"node":{"fields":{"slug":"/api/pool","title":"pg.Pool","filename":{"name":"1-pool"}}}},{"node":{"fields":{"slug":"/","title":"Welcome","filename":{"name":"welcome"}}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"96180818-30b8-53e6-a213-629ddc66f144"}}}