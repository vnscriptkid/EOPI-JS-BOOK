{"componentChunkName":"component---src-templates-docs-js","path":"/guides/upgrading","webpackCompilationHash":"e536b55f7567f3131f54","result":{"data":{"site":{"siteMetadata":{"title":"EOPI-JS","docsLocation":"https://github.com/brianc/node-postgres-docs/tree/master/content"}},"mdx":{"fields":{"id":"ba78d199-d998-5d08-8d65-f39db08aa04f","title":"Upgrading","slug":"/guides/upgrading"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Upgrading\",\n  \"slug\": \"/guides/upgrading\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"upgrading-to-80\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Upgrading to 8.0\"), mdx(\"p\", null, \"node-postgres at 8.0 introduces a breaking change to ssl-verified connections.  If you connect with ssl and use\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"const client = new Client({ ssl: true })\\n\")), mdx(\"p\", null, \"and the server's SSL certificate is self-signed, connections will fail as of node-postgres 8.0.  To keep the existing behavior, modify the invocation to\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"const client = new Client({ ssl: { rejectUnauthorized: false } })\\n\")), mdx(\"p\", null, \"The rest of the changes are relatively minor and unlikely to cause issues; see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/announcements#2020-02-25\"\n  }), \"the announcement\"), \" for full details.\"), mdx(\"h1\", {\n    \"id\": \"upgrading-to-70\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Upgrading to 7.0\"), mdx(\"p\", null, \"node-postgres at 7.0 introduces somewhat significant breaking changes to the public API.\"), mdx(\"h2\", {\n    \"id\": \"node-version-support\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"node version support\"), mdx(\"p\", null, \"Starting with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \" the earliest version of node supported will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node@4.x LTS\"), \". Support for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node@0.12.x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node@.10.x\"), \" is dropped, and the module wont work as it relies on new es6 features not available in older versions of node.\"), mdx(\"h2\", {\n    \"id\": \"pg-singleton\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"pg singleton\"), mdx(\"p\", null, \"In the past there was a singleton pool manager attached to the root \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg\"), \" object in the package. This singleton could be used to provision connection pools automatically by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg.connect\"), \". This API caused a lot of confusion for users. It also introduced a opaque module-managed singleton which was difficult to reason about, debug, error-prone, and inflexible. Starting in pg@6.0 the methods' documentation was removed, and starting in pg@6.3 the methods were deprecated with a warning message.\"), mdx(\"p\", null, \"If your application still relies on these they will be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"gone\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \". In order to migrate you can do the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// old way, deprecated in 6.3.0:\\n\\n// connection using global singleton\\npg.connect(function(err, client, done) {\\n  client.query(/* etc, etc */)\\n  done()\\n})\\n\\n// singleton pool shutdown\\npg.end()\\n\\n// ------------------\\n\\n// new way, available since 6.0.0:\\n\\n// create a pool\\nvar pool = new pg.Pool()\\n\\n// connection using created pool\\npool.connect(function(err, client, done) {\\n  client.query(/* etc, etc */)\\n  done()\\n})\\n\\n// pool shutdown\\npool.end()\\n\")), mdx(\"p\", null, \"node-postgres ships with a built-in pool object provided by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-pool\"\n  }), \"pg-pool\"), \" which is already used internally by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg.connect\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg.end\"), \" methods. Migrating to a user-managed pool (or set of pools) allows you to more directly control their set up their life-cycle.\"), mdx(\"h2\", {\n    \"id\": \"clientqueryon\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"client.query(...).on\"), mdx(\"p\", null, \"Before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" method would \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"always\"), \" return an instance of a query. The query instance was an event emitter, accepted a callback, and was also a promise. A few problems...\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"too many flow control options on a single object was confusing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"event emitter \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".on('error')\"), \" does not mix well with promise \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".catch\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"row\"), \" event was a common source of errors: it looks like a stream but has no support for back-pressure, misleading users into trying to pipe results or handling them in the event emitter for a desired performance gain.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"error handling with a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".done\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".error\"), \" emitter pair for every query is cumbersome and returning the emitter from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"client.query\"), \" indicated this sort of pattern may be encouraged: it is not.\")), mdx(\"p\", null, \"Starting with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \" the return value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" will be dependent on what you pass to the method: I think this aligns more with how most node libraries handle the callback/promise combo, and I hope it will make the \\\"just works\\\" :tm: feeling better while reducing surface area and surprises around event emitter / callback combos.\"), mdx(\"h3\", {\n    \"id\": \"clientquery-with-a-callback\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"client.query with a callback\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = client.query('SELECT NOW()', (err, res) => {\\n  /* etc, etc */\\n})\\nassert(query === undefined) // true\\n\")), mdx(\"p\", null, \"If you pass a callback to the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" will return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". This limits flow control to the callback which is in-line with almost all of node's core APIs.\"), mdx(\"h3\", {\n    \"id\": \"clientquery-without-a-callback\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"client.query without a callback\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = client.query('SELECT NOW()')\\nassert(query instanceof Promise) // true\\nassert(query.on === undefined) // true\\nquery.then((res) => /* etc, etc */)\\n\")), mdx(\"p\", null, \"If you do \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" pass a callback \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" will return an instance of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \". This will \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" be a query instance and will not be an event emitter. This is in line with how most promise-based APIs work in node.\"), mdx(\"h3\", {\n    \"id\": \"clientquerysubmittable\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"client.query(Submittable)\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" has always accepted any object that has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".submit\"), \" method on it. In this scenario the client calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".submit\"), \" on the object, delegating execution responsibility to it. In this situation the client also \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"returns the instance it was passed\"), \". This is how \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-cursor\"\n  }), \"pg-cursor\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-query-stream\"\n  }), \"pg-query-stream\"), \" work. So, if you need the event emitter functionality on your queries for some reason, it is still possible because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" is an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Submittable\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client, Query } = require('pg')\\nconst query = client.query(new Query('SELECT NOW()'))\\nquery.on('row', row => {})\\nquery.on('end', res => {})\\nquery.on('error', res => {})\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" is considered a public, documented part of the API of node-postgres and this form will be supported indefinitely.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I have been building apps with node-postgres for almost 7 years. In that time I have never used the event emitter API as the primary way to execute queries. I used to use callbacks and now I use async/await. If you need to stream results I highly recommend you use \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-cursor\"\n  }), \"pg-cursor\"), \" or \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-query-stream\"\n  }), \"pg-query-stream\"), \" and \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"not\"), \" the query object as an event emitter.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#upgrading-to-80","title":"Upgrading to 8.0"},{"url":"#upgrading-to-70","title":"Upgrading to 7.0","items":[{"url":"#node-version-support","title":"node version support"},{"url":"#pg-singleton","title":"pg singleton"},{"url":"#clientqueryon","title":"client.query(...).on","items":[{"url":"#clientquery-with-a-callback","title":"client.query with a callback"},{"url":"#clientquery-without-a-callback","title":"client.query without a callback"},{"url":"#clientquerysubmittable","title":"client.query(Submittable)"}]}]}]},"parent":{"__typename":"File","relativePath":"guides/3-upgrading.md"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/features","title":"Features","filename":{"name":"features"}}}},{"node":{"fields":{"slug":"/guides","title":"Guides","filename":{"name":"guides"}}}},{"node":{"fields":{"slug":"/api","title":"API","filename":{"name":"api"}}}},{"node":{"fields":{"slug":"/api/result","title":"pg.Result","filename":{"name":"3-result"}}}},{"node":{"fields":{"slug":"/api/types","title":"Types","filename":{"name":"4-types"}}}},{"node":{"fields":{"slug":"/features/queries","title":"Queries","filename":{"name":"2-queries"}}}},{"node":{"fields":{"slug":"/features/pooling","title":"Pooling","filename":{"name":"3-pooling"}}}},{"node":{"fields":{"slug":"/features/transactions","title":"Transactions","filename":{"name":"4-transactions"}}}},{"node":{"fields":{"slug":"/features/ssl","title":"SSL","filename":{"name":"6-ssl"}}}},{"node":{"fields":{"slug":"/features/native","title":"Native Bindings","filename":{"name":"7-native"}}}},{"node":{"fields":{"slug":"/features/types","title":"Data Types","filename":{"name":"5-types"}}}},{"node":{"fields":{"slug":"/features/connecting","title":"Connecting","filename":{"name":"1-connecting"}}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Suggested Project Structure","filename":{"name":"1-project-structure"}}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Express with async/await","filename":{"name":"2-async-express"}}}},{"node":{"fields":{"slug":"/api/cursor","title":"pg.Cursor","filename":{"name":"5-cursor"}}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading","filename":{"name":"3-upgrading"}}}},{"node":{"fields":{"slug":"/announcements","title":"Announcements","filename":{"name":"announcements"}}}},{"node":{"fields":{"slug":"/api/client","title":"pg.Client","filename":{"name":"2-client"}}}},{"node":{"fields":{"slug":"/api/pool","title":"pg.Pool","filename":{"name":"1-pool"}}}},{"node":{"fields":{"slug":"/","title":"Welcome","filename":{"name":"welcome"}}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"ba78d199-d998-5d08-8d65-f39db08aa04f"}}}